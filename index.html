<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Φ Sphere Packing Lab — 3D (WebGL, Hinged, Adjacent-only)</title>
<meta name="description" content="Explore φ-scaled sphere packing with hinged links and adjacent-only snapping." />
<style>
  :root { --bg:#0f1220; --fg:#e8eefc; --muted:#9bb1ff; --line:#202645; --pill:#2a315d; }
  html, body { height: 100%; }
  body { margin: 0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background: var(--bg); color: var(--fg); }
  header { position: sticky; top: 0; z-index: 5; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; padding: 10px 12px; border-bottom: 1px solid var(--line); background: #0c1020; }
  header .group { display: flex; gap: 8px; align-items: center; }
  header label { font-size: 13px; color: var(--muted); }
  select, button, input[type="range"] {
    background:#161a2e; color:var(--fg); border:1px solid #29305a; border-radius:6px; padding:6px 8px; font-size:14px;
  }
  button.primary { border-color: #3b67ff; }
  #diag { padding: 8px 12px; font-size: 13px; min-height: 18px; }
  #mode { display:inline-block; padding:2px 8px; border:1px solid var(--pill); border-radius:999px; font-size:12px; margin-left:6px; }
  #viewport { position: relative; min-height: 640px; height: 90vh; border-top: 1px solid var(--line);
              background: radial-gradient(ellipse at top, #161a2e, #0b0f1f 60%); }
  canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
  footer { padding: 10px 12px; border-top:1px solid var(--line); color:#9fb3ff; font-size:12px; }
</style>
</head>
<body>
  <header>
    <div class="group">
      <label>Φ exponent</label>
      <select id="exp"></select>
      <button id="add" class="primary">Add sphere</button>
      <button id="addSet">Add φ→φ⁻⁹ set</button>
      <button id="clear">Clear</button>
    </div>
    <div class="group">
      <label><input type="checkbox" id="magnet" checked /> Magnetism</label>
      <label>Snap tol</label>
      <input id="snap" type="range" min="0" max="1" step="0.005" value="0.06" />
      <span id="snapv">0.06</span>
    </div>
    <div class="group">
      <span id="mode">Mode: WebGL 3D</span>
    </div>
  </header>

  <div id="diag"></div>
  <div id="viewport"></div>

  <footer>
    Hinged links • Adjacent-only snapping (|Δφ exponent| = 1) • Drag to move spheres • Drag background to orbit • Wheel to zoom
  </footer>

  <!-- Classic scripts (non-module) to avoid import/CORS issues on Pages -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  (function(){
    const PHI = (1 + Math.sqrt(5)) / 2;
    const EXPS = [1,-1,-2,-3,-4,-5,-6,-7,-8,-9]; // 10 sizes
    const COLORS = Array.from({length:EXPS.length},(_,i)=>new THREE.Color().setHSL((i/EXPS.length), 1.0, 0.6));
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const colorForExp = e => COLORS[Math.max(0,EXPS.indexOf(e))];
    const radiusForExp = (e, base=0.6)=> base*Math.pow(PHI, e);

    const wrap = document.getElementById('viewport');
    const diag = (msg)=>{ document.getElementById('diag').textContent = msg||''; };

    // --- renderer/scene/camera ---
    let gl;
    try {
      gl = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    } catch (e) {
      diag('WebGL failed to create a context in this browser/environment.');
      return;
    }
    gl.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    gl.setSize(Math.max(2, wrap.clientWidth), Math.max(2, wrap.clientHeight), false);
    wrap.appendChild(gl.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, 1, 0.01, 200);
    camera.position.set(0, 2.4, 6);

    const controls = new THREE.OrbitControls(camera, gl.domElement);
    controls.enableDamping = true;

    const hemi = new THREE.HemisphereLight(0xffffff, 0x404040, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(4, 7, 6);
    scene.add(dir);
    scene.add(new THREE.GridHelper(100, 100, 0x444444, 0x222222));

    // --- state ---
    const state = { nodes:[], links:[], magnet:true, snapTol:0.06, nextId:1 };
    const spheres = new Map();  // id -> Mesh
    const cylinders = [];

    const findNode = id => state.nodes.find(n=>n.id===id);
    const neighborsOf = id => {
      const ids=[];
      for (const l of state.links) {
        if (l.aId===id) ids.push(l.bId);
        else if (l.bId===id) ids.push(l.aId);
      }
      return ids.map(findNode).filter(Boolean);
    };

    // --- UI wiring ---
    function populateExp() {
      const sel = document.getElementById('exp');
      EXPS.forEach(e => {
        const o = document.createElement('option');
        o.value = String(e);
        o.textContent = `φ^${e}`;
        sel.appendChild(o);
      });
    }
    populateExp();

    document.getElementById('magnet').onchange = e => { state.magnet = e.target.checked; };
    document.getElementById('snap').oninput = e => {
      state.snapTol = parseFloat(e.target.value);
      document.getElementById('snapv').textContent = state.snapTol.toFixed(2);
    };
    document.getElementById('add').onclick = () => {
      const exp = parseFloat(document.getElementById('exp').value);
      addSphere(exp); syncFromState();
    };
    document.getElementById('addSet').onclick = () => { addPhiSet(); syncFromState(); };
    document.getElementById('clear').onclick = () => { state.nodes.length=0; state.links.length=0; syncFromState(); };

    // --- helpers ---
    function addSphere(exp, pos=null) {
      const n = {
        id: state.nextId++,
        exp,
        r: radiusForExp(exp),
        color: colorForExp(exp),
        pos: pos ? pos.clone() : new THREE.Vector3((Math.random()-0.5)*2, radiusForExp(exp), (Math.random()-0.5)*2)
      };
      state.nodes.push(n);
      return n;
    }

    function addPhiSet() {
      let x = -3;
      for (const e of EXPS) {
        const n = addSphere(e, new THREE.Vector3(x, radiusForExp(e), 0));
        x += n.r*2 + 0.12;
      }
    }

    function clearLinksMeshes() {
      for (const m of cylinders) { scene.remove(m); m.geometry.dispose(); m.material.dispose(); }
      cylinders.length = 0;
    }

    function rebuildLinksMeshes() {
      clearLinksMeshes();
      const up = new THREE.Vector3(0,1,0);
      const dir = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      for (const l of state.links) {
        const A = findNode(l.aId), B = findNode(l.bId);
        if (!A || !B) continue;
        const av = A.pos, bv = B.pos;
        dir.subVectors(bv, av);
        const len = dir.length();
        if (len < 1e-9) continue;
        dir.normalize();
        const axis = new THREE.Vector3().crossVectors(up, dir).normalize();
        const angle = Math.acos(clamp(up.dot(dir), -1, 1));
        quat.setFromAxisAngle(axis, angle);
        const radius = Math.min(0.05, 0.3 * Math.min(A.r, B.r));
        const geom = new THREE.CylinderGeometry(radius, radius, len, 16);
        const mat = new THREE.MeshStandardMaterial({ color: 0xcfd9ff, roughness: 0.7, metalness: 0.0 });
        const m = new THREE.Mesh(geom, mat);
        m.quaternion.copy(quat);
        m.position.copy(av).addScaledVector(dir, len/2);
        scene.add(m);
        cylinders.push(m);
      }
    }

    function syncFromState() {
      for (const n of state.nodes) {
        let mesh = spheres.get(n.id);
        if (!mesh) {
          const geom = new THREE.SphereGeometry(n.r, 32, 16);
          const mat = new THREE.MeshStandardMaterial({ color: n.color, roughness: 0.35, metalness: 0.05 });
          mesh = new THREE.Mesh(geom, mat);
          mesh.userData.id = n.id;
          scene.add(mesh);
          spheres.set(n.id, mesh);
        }
        mesh.position.copy(n.pos);
        mesh.material.color = n.color;
        const cr = mesh.geometry.parameters?.radius ?? n.r;
        if (Math.abs(cr - n.r) > 1e-6) {
          mesh.geometry.dispose();
          mesh.geometry = new THREE.SphereGeometry(n.r, 32, 16);
        }
      }
      for (const [id, mesh] of spheres) {
        if (!state.nodes.some(n=>n.id===id)) {
          scene.remove(mesh); mesh.geometry.dispose(); mesh.material.dispose(); spheres.delete(id);
        }
      }
      rebuildLinksMeshes();
    }

    // --- hinges (keep contact to neighbors) ---
    function applyHinges(id) {
      const n = findNode(id); if (!n) return;
      const neigh = neighborsOf(id);
      if (!neigh.length) return;
      const acc = new THREE.Vector3();
      for (const m of neigh) {
        const rSum = n.r + m.r;
        const dir = new THREE.Vector3().subVectors(n.pos, m.pos);
        const len = dir.length();
        if (len < 1e-9) dir.set(1,0,0);
        else dir.multiplyScalar(1/len);
        acc.add(new THREE.Vector3().copy(m.pos).addScaledVector(dir, rSum));
      }
      acc.multiplyScalar(1/neigh.length);
      n.pos.copy(acc);
    }

    // --- magnet snap (adjacent-only) ---
    function tryMagnetSnap(id) {
      if (!state.magnet) return;
      const n = findNode(id); if (!n) return;
      const nIdx = EXPS.indexOf(n.exp);
      let best=null, bestErr=Infinity;

      for (const m of state.nodes) {
        if (m.id === n.id) continue;
        if (Math.abs(EXPS.indexOf(m.exp) - nIdx) !== 1) continue; // adjacent-only
        const target = n.r + m.r;
        const d = n.pos.distanceTo(m.pos);
        const err = Math.abs(d - target);
        const tol = state.snapTol * Math.max(n.r, m.r);
        if (err <= tol && err < bestErr) { bestErr=err; best=m; }
      }
      if (!best) return;

      const rSum = n.r + best.r;
      const dir = new THREE.Vector3().subVectors(n.pos, best.pos);
      const len = dir.length();
      if (len < 1e-9) dir.set(1,0,0); else dir.multiplyScalar(1/len);
      n.pos.copy(best.pos).addScaledVector(dir, rSum);

      if (!state.links.some(l=>(l.aId===n.id && l.bId===best.id) || (l.aId===best.id && l.bId===n.id))) {
        state.links.push({ aId: n.id, bId: best.id });
      }
      syncFromState();
    }

    // --- interactions ---
    const ray = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let dragging = null;

    gl.domElement.addEventListener('pointerdown', (e)=>{
      const r = gl.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - r.left)/r.width)*2 - 1;
      mouse.y = -(((e.clientY - r.top)/r.height)*2 - 1);
      ray.setFromCamera(mouse, camera);
      const hits = ray.intersectObjects(Array.from(spheres.values()));
      if (hits.length) {
        dragging = hits[0].object.userData.id;
        gl.domElement.setPointerCapture(e.pointerId);
        controls.enabled = false;
      }
    });

    gl.domElement.addEventListener('pointermove', (e)=>{
      if (!dragging) return;
      const normal = new THREE.Vector3().subVectors(camera.position, new THREE.Vector3(0,0,0)).normalize();
      const plane = new THREE.Plane(normal, 0);
      const r = gl.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - r.left)/r.width)*2 - 1;
      mouse.y = -(((e.clientY - r.top)/r.height)*2 - 1);
      ray.setFromCamera(mouse, camera);
      const hit = new THREE.Vector3();
      ray.ray.intersectPlane(plane, hit);
      const n = findNode(dragging);
      n.pos.copy(hit);
      applyHinges(dragging);
      syncFromState();
    });

    gl.domElement.addEventListener('pointerup', (e)=>{
      if (!dragging) return;
      const id = dragging; dragging = null;
      tryMagnetSnap(id);
      syncFromState();
      gl.domElement.releasePointerCapture(e.pointerId);
      controls.enabled = true;
    });

    // --- resize & animate ---
    function resize(){
      const w = Math.max(2, wrap.clientWidth);
      const h = Math.max(2, wrap.clientHeight);
      gl.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    new ResizeObserver(resize).observe(wrap);

    function tick(){
      controls.update();
      gl.render(scene, camera);
      requestAnimationFrame(tick);
    }

    // seed and go
    (function addPhiSet(){
      let x=-3;
      for (const e of EXPS) {
        const n = addSphere(e, new THREE.Vector3(x, radiusForExp(e), 0));
        x += n.r*2 + 0.12;
      }
    })();
    syncFromState();
    diag('Drag spheres to move; release to snap. Only adjacent φ exponents will connect.');
    tick();
  })();
  </script>
</body>
</html>
